import { connect, createConfig, getAccount, getBalance, getConnections, injected, prepareTransactionRequest, reconnect, signMessage, switchChain, disconnect as wagmiDisconnect, estimateGas as wagmiEstimateGas, sendTransaction as wagmiSendTransaction, writeContract as wagmiWriteContract, waitForTransactionReceipt, watchAccount, watchConnections, watchConnectors, watchPendingTransactions } from '@wagmi/core';
import {} from '@wagmi/core/chains';
import { UserRejectedRequestError as ViemUserRejectedRequestError, checksumAddress, formatUnits, parseUnits } from 'viem';
import { ErrorUtil, UserRejectedRequestError } from '@reown/appkit-common';
import { ConstantsUtil as CommonConstantsUtil, NetworkUtil } from '@reown/appkit-common';
import { AdapterBlueprint, AssetController, ChainController, CoreHelperUtil, OptionsController, StorageUtil, WalletConnectConnector } from '@reown/appkit-controllers';
import {} from '@reown/appkit-controllers';
import { CaipNetworksUtil, HelpersUtil, PresetsUtil } from '@reown/appkit-utils';
import { authConnector } from './connectors/AuthConnector.js';
import { walletConnect } from './connectors/WalletConnectConnector.js';
import { LimitterUtil } from './utils/LimitterUtil.js';
import { getBaseAccountConnector, getSafeConnector } from './utils/helpers.js';
const DEFAULT_PENDING_TRANSACTIONS_FILTER = {
    enable: false,
    pollingInterval: 30_000
};
export class WagmiAdapter extends AdapterBlueprint {
    constructor(configParams) {
        const networks = CaipNetworksUtil.extendCaipNetworks(configParams.networks, {
            projectId: configParams.projectId,
            customNetworkImageUrls: {},
            customRpcUrls: configParams.customRpcUrls
        });
        super();
        this.balancePromises = {};
        this.namespace = CommonConstantsUtil.CHAIN.EVM;
        this.adapterType = CommonConstantsUtil.ADAPTER_TYPES.WAGMI;
        this.projectId = configParams.projectId;
        this.pendingTransactionsFilter = {
            ...DEFAULT_PENDING_TRANSACTIONS_FILTER,
            ...(configParams.pendingTransactionsFilter ?? {})
        };
        this.createConfig({ ...configParams, networks });
        this.checkChainId();
    }
    construct(_options) {
        this.checkChainId();
        this.setupWatchers();
    }
    async getAccounts(params) {
        const connector = this.getWagmiConnector(params.id);
        if (!connector) {
            return { accounts: [] };
        }
        if (connector.id === CommonConstantsUtil.CONNECTOR_ID.AUTH) {
            const provider = (await connector.getProvider());
            if (!provider?.user) {
                return { accounts: [] };
            }
            const { address, accounts } = provider.user;
            return Promise.resolve({
                accounts: (accounts || [{ address, type: 'eoa' }]).map(account => CoreHelperUtil.createAccount('eip155', account.address, account.type))
            });
        }
        const { addresses, address } = getAccount(this.wagmiConfig);
        return Promise.resolve({
            accounts: [...new Set(addresses || [address])]?.map(val => CoreHelperUtil.createAccount('eip155', val || '', 'eoa'))
        });
    }
    checkChainId() {
        const { chainId } = getAccount(this.wagmiConfig);
        if (chainId) {
            this.emit('switchNetwork', {
                chainId
            });
        }
    }
    getWagmiConnector(id) {
        return this.wagmiConfig.connectors.find(c => c.id === id);
    }
    createConfig(configParams) {
        this.wagmiChains = configParams.networks.filter(caipNetwork => caipNetwork.chainNamespace === CommonConstantsUtil.CHAIN.EVM);
        const transports = {};
        const connectors = [...(configParams.connectors ?? [])];
        this.wagmiChains.forEach(element => {
            const fromTransportProp = configParams.transports?.[element.id];
            const caipNetworkId = CaipNetworksUtil.getCaipNetworkId(element);
            if (fromTransportProp) {
                transports[element.id] = CaipNetworksUtil.extendWagmiTransports(element, configParams.projectId, fromTransportProp);
            }
            else {
                transports[element.id] = CaipNetworksUtil.getViemTransport(element, configParams.projectId, configParams.customRpcUrls?.[caipNetworkId]);
            }
        });
        this.wagmiConfig = createConfig({
            ...configParams,
            chains: this.wagmiChains,
            connectors,
            transports
        });
    }
    setupWatchPendingTransactions() {
        if (!this.pendingTransactionsFilter.enable || this.unwatchPendingTransactions) {
            return;
        }
        this.unwatchPendingTransactions = watchPendingTransactions(this.wagmiConfig, {
            pollingInterval: this.pendingTransactionsFilter.pollingInterval,
            onError: () => { },
            onTransactions: () => {
                this.emit('pendingTransactions');
                LimitterUtil.increase('pendingTransactions');
            }
        });
        const unsubscribe = LimitterUtil.subscribeKey('pendingTransactions', val => {
            if (val >= CommonConstantsUtil.LIMITS.PENDING_TRANSACTIONS) {
                this.unwatchPendingTransactions?.();
                unsubscribe();
            }
        });
    }
    setupWatchers() {
        watchConnections(this.wagmiConfig, {
            onChange: connections => {
                this.clearConnections();
                this.addConnection(...connections.map(connection => {
                    const caipNetwork = this.getCaipNetworks().find(network => network.id === connection.chainId);
                    const isAuth = connection.connector.id === CommonConstantsUtil.CONNECTOR_ID.AUTH;
                    return {
                        accounts: connection.accounts.map(account => ({
                            address: this.toChecksummedAddress(account)
                        })),
                        caipNetwork,
                        connectorId: connection.connector.id,
                        auth: isAuth
                            ? {
                                name: StorageUtil.getConnectedSocialProvider(),
                                username: StorageUtil.getConnectedSocialUsername()
                            }
                            : undefined
                    };
                }));
            }
        });
        watchAccount(this.wagmiConfig, {
            onChange: (accountData, prevAccountData) => {
                if (accountData.status === 'disconnected' && prevAccountData.address) {
                    this.emit('disconnect');
                }
                if (accountData?.chainId && accountData?.chainId !== prevAccountData?.chainId) {
                    this.emit('switchNetwork', {
                        chainId: accountData.chainId
                    });
                }
                if (accountData.status === 'connected') {
                    const hasAccountChanged = accountData.address !== prevAccountData?.address;
                    const hasConnectorChanged = accountData.connector.id !== prevAccountData.connector?.id;
                    const hasConnectionStatusChanged = prevAccountData.status !== 'connected';
                    if (hasAccountChanged || hasConnectorChanged || hasConnectionStatusChanged) {
                        this.setupWatchPendingTransactions();
                        this.handleAccountChanged({
                            address: accountData.address,
                            chainId: accountData.chainId,
                            connector: accountData.connector
                        });
                    }
                }
            }
        });
    }
    async addThirdPartyConnectors() {
        const thirdPartyConnectors = [];
        const { enableCoinbase: isCoinbaseEnabled } = OptionsController.state || {};
        if (isCoinbaseEnabled !== false) {
            const baseAccountConnector = await getBaseAccountConnector(this.wagmiConfig.connectors);
            if (baseAccountConnector) {
                thirdPartyConnectors.push(baseAccountConnector);
            }
        }
        const safeConnector = await getSafeConnector(this.wagmiConfig.connectors);
        if (safeConnector) {
            thirdPartyConnectors.push(safeConnector);
        }
        await Promise.all(thirdPartyConnectors.map(connector => {
            const cnctr = this.configureInternalConnector(connector);
            return this.addWagmiConnector(cnctr);
        }));
    }
    addWagmiConnectors() {
        const customConnectors = [];
        if (OptionsController.state.enableInjected !== false) {
            customConnectors.push(injected({ shimDisconnect: true }));
        }
        const { features, remoteFeatures, projectId, enableAuthLogger: isAuthLoggerEnabled } = OptionsController.state;
        const isEmailEnabled = remoteFeatures?.email ?? features?.email ?? true;
        const socials = remoteFeatures?.socials ?? features?.socials;
        const isSocialsEnabled = Array.isArray(socials) && socials?.length > 0;
        if (isEmailEnabled || isSocialsEnabled) {
            customConnectors.push(authConnector({
                chains: this.wagmiChains,
                options: { projectId, enableAuthLogger: isAuthLoggerEnabled }
            }));
        }
        customConnectors.forEach(connector => {
            this.configureInternalConnector(connector);
        });
    }
    configureInternalConnector(connector) {
        const cnctr = this.wagmiConfig._internal.connectors.setup(connector);
        this.wagmiConfig._internal.connectors.setState(prev => [...prev, cnctr]);
        return cnctr;
    }
    async handleAccountChanged({ address, chainId, connector }) {
        if (!this.namespace) {
            throw new Error('WagmiAdapter:handleAccountChanged - namespace is required');
        }
        const provider = (await connector.getProvider().catch(() => undefined));
        this.emit('accountChanged', {
            address: this.toChecksummedAddress(address),
            chainId,
            connector: {
                id: connector.id,
                name: PresetsUtil.ConnectorNamesMap[connector.id] ?? connector.name,
                imageId: PresetsUtil.ConnectorImageIds[connector.id],
                type: PresetsUtil.ConnectorTypesMap[connector.type] ?? 'EXTERNAL',
                info: connector.id === CommonConstantsUtil.CONNECTOR_ID.INJECTED
                    ? undefined
                    : { rdns: connector.id },
                provider,
                chain: this.namespace,
                chains: []
            }
        });
    }
    async signMessage(params) {
        try {
            const signature = await signMessage(this.wagmiConfig, {
                message: params.message,
                account: params.address
            });
            return { signature };
        }
        catch (error) {
            throw new Error('WagmiAdapter:signMessage - Sign message failed');
        }
    }
    async sendTransaction(params) {
        const { chainId, address } = getAccount(this.wagmiConfig);
        const wagmiChain = this.wagmiChains?.find(chain => chain.id === chainId);
        const txParams = {
            account: address,
            to: params.to,
            value: Number.isNaN(Number(params.value)) ? BigInt(0) : BigInt(params.value),
            gas: params.gas ? BigInt(params.gas) : undefined,
            gasPrice: params.gasPrice ? BigInt(params.gasPrice) : undefined,
            data: params.data,
            chain: wagmiChain,
            type: 'legacy',
            parameters: ['nonce']
        };
        await prepareTransactionRequest(this.wagmiConfig, txParams);
        const tx = await wagmiSendTransaction(this.wagmiConfig, txParams);
        await waitForTransactionReceipt(this.wagmiConfig, { hash: tx, timeout: 25000 });
        return { hash: tx };
    }
    async writeContract(params) {
        const { caipNetwork, ...data } = params;
        const chainId = Number(NetworkUtil.caipNetworkIdToNumber(caipNetwork.caipNetworkId));
        const wagmiChain = this.wagmiChains?.find(chain => chain.id === chainId);
        const tx = await wagmiWriteContract(this.wagmiConfig, {
            chain: wagmiChain,
            address: data.tokenAddress,
            account: data.fromAddress,
            abi: data.abi,
            functionName: data.method,
            args: data.args,
            __mode: 'prepared'
        });
        return { hash: tx };
    }
    async estimateGas(params) {
        try {
            const result = await wagmiEstimateGas(this.wagmiConfig, {
                account: params.address,
                to: params.to,
                data: params.data,
                type: 'legacy'
            });
            return { gas: result };
        }
        catch (error) {
            throw new Error('WagmiAdapter:estimateGas - error estimating gas');
        }
    }
    parseUnits(params) {
        return parseUnits(params.value, params.decimals);
    }
    formatUnits(params) {
        return formatUnits(params.value, params.decimals);
    }
    async addWagmiConnector(connector) {
        if (!this.namespace) {
            throw new Error('WagmiAdapter:addWagmiConnector - namespace is required');
        }
        const { enableEIP6963: isEIP6963Enabled } = OptionsController.state || {};
        if (connector.type === CommonConstantsUtil.CONNECTOR_ID.INJECTED &&
            isEIP6963Enabled === false) {
            return;
        }
        if (connector.id === CommonConstantsUtil.CONNECTOR_ID.AUTH ||
            connector.id === CommonConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
            return;
        }
        let provider = undefined;
        if (connector.id !== CommonConstantsUtil.CONNECTOR_ID.BASE_ACCOUNT) {
            provider = (await connector.getProvider().catch(() => undefined));
        }
        const customConnectorImages = AssetController.state.connectorImages;
        this.addConnector({
            id: connector.id,
            explorerId: PresetsUtil.ConnectorExplorerIds[connector.id],
            imageUrl: customConnectorImages?.[connector.id] ?? connector.icon,
            name: PresetsUtil.ConnectorNamesMap[connector.id] ?? connector.name,
            imageId: PresetsUtil.ConnectorImageIds[connector.id],
            type: PresetsUtil.ConnectorTypesMap[connector.type] ?? 'EXTERNAL',
            info: connector.id === CommonConstantsUtil.CONNECTOR_ID.INJECTED
                ? undefined
                : { rdns: connector.id },
            provider,
            chain: this.namespace,
            chains: []
        });
    }
    async syncConnectors() {
        watchConnectors(this.wagmiConfig, {
            onChange: connectors => {
                connectors.forEach(connector => this.addWagmiConnector(connector));
            }
        });
        this.addWagmiConnectors();
        await Promise.all(this.wagmiConfig.connectors.map(connector => this.addWagmiConnector(connector)));
        await this.addThirdPartyConnectors();
    }
    async syncConnections() {
        const wagmiConnectors = this.connectors
            .filter(c => {
            const { hasDisconnected, hasConnected } = HelpersUtil.getConnectorStorageInfo(c.id, this.namespace);
            return !hasDisconnected && hasConnected;
        })
            .map(connector => this.getWagmiConnector(connector.id))
            .filter(Boolean);
        await reconnect(this.wagmiConfig, {
            connectors: wagmiConnectors
        });
    }
    async syncConnection(params) {
        const { id, chainId } = params;
        const connections = getConnections(this.wagmiConfig);
        const connection = connections.find(c => c.connector.id === id);
        const connector = this.getWagmiConnector(id);
        const provider = (await connector?.getProvider());
        const isSafeApp = CoreHelperUtil.isSafeApp();
        if (isSafeApp && id === CommonConstantsUtil.CONNECTOR_ID.SAFE && !connection?.accounts.length) {
            const safeAppConnector = this.getWagmiConnector('safe');
            if (safeAppConnector) {
                const res = await connect(this.wagmiConfig, {
                    connector: safeAppConnector,
                    chainId: Number(chainId)
                });
                const safeProvider = (await safeAppConnector.getProvider());
                return {
                    chainId: Number(chainId),
                    address: this.toChecksummedAddress(res.accounts[0]),
                    provider: safeProvider,
                    type: connection?.connector.type?.toUpperCase(),
                    id: connection?.connector.id
                };
            }
        }
        return {
            chainId: Number(connection?.chainId),
            address: this.toChecksummedAddress(connection?.accounts[0]),
            provider,
            type: connection?.connector.type?.toUpperCase(),
            id: connection?.connector.id
        };
    }
    async connectWalletConnect(chainId) {
        try {
            const walletConnectConnector = this.getWalletConnectConnector();
            await walletConnectConnector.authenticate();
            const wagmiConnector = this.getWagmiConnector('walletConnect');
            if (!wagmiConnector) {
                throw new Error('UniversalAdapter:connectWalletConnect - connector not found');
            }
            const res = await connect(this.wagmiConfig, {
                connector: wagmiConnector,
                chainId: chainId ? Number(chainId) : undefined
            });
            if (res.chainId !== Number(chainId)) {
                await switchChain(this.wagmiConfig, { chainId: res.chainId });
            }
            return { clientId: await walletConnectConnector.provider.client.core.crypto.getClientId() };
        }
        catch (err) {
            if (err instanceof ViemUserRejectedRequestError) {
                throw new UserRejectedRequestError(err);
            }
            if (ErrorUtil.isUserRejectedRequestError(err)) {
                throw new UserRejectedRequestError(err);
            }
            throw err;
        }
    }
    async connect(params) {
        try {
            const { id, address, provider, type, info, chainId, socialUri } = params;
            const connector = this.getWagmiConnector(id);
            if (!connector) {
                throw new Error('connectionControllerClient:connectExternal - connector is undefined');
            }
            if (provider && info && connector.id === CommonConstantsUtil.CONNECTOR_ID.EIP6963) {
                connector.setEip6963Wallet?.({ provider, info });
            }
            const connection = this.wagmiConfig.state?.connections?.get(connector.uid);
            if (connection) {
                await this.wagmiConfig.storage?.setItem('recentConnectorId', connector.id);
                const sortedAccounts = [...connection.accounts].sort((a, b) => {
                    if (HelpersUtil.isLowerCaseMatch(a, address)) {
                        return -1;
                    }
                    if (HelpersUtil.isLowerCaseMatch(b, address)) {
                        return 1;
                    }
                    return 0;
                });
                this.wagmiConfig?.setState(x => ({
                    ...x,
                    connections: new Map(x.connections).set(connector.uid, {
                        accounts: sortedAccounts,
                        chainId: connection.chainId,
                        connector: connection.connector
                    }),
                    current: connector.uid,
                    status: 'connected'
                }));
                return {
                    address: this.toChecksummedAddress(sortedAccounts[0]),
                    chainId: connection.chainId,
                    provider: provider,
                    type: type,
                    id
                };
            }
            const res = await connect(this.wagmiConfig, {
                connector,
                chainId: chainId ? Number(chainId) : undefined,
                socialUri
            });
            const resolvedProvider = provider ?? (await connector.getProvider());
            return {
                address: this.toChecksummedAddress(res.accounts[0]),
                chainId: res.chainId,
                provider: resolvedProvider,
                type: type,
                id
            };
        }
        catch (err) {
            if (err instanceof ViemUserRejectedRequestError) {
                throw new UserRejectedRequestError(err);
            }
            if (ErrorUtil.isUserRejectedRequestError(err)) {
                throw new UserRejectedRequestError(err);
            }
            throw err;
        }
    }
    get connections() {
        return Array.from(this.wagmiConfig.state.connections.values()).map(connection => ({
            accounts: connection.accounts.map(account => ({
                address: this.toChecksummedAddress(account)
            })),
            connectorId: connection.connector.id
        }));
    }
    async reconnect(params) {
        const { id } = params;
        const connector = this.getWagmiConnector(id);
        if (!connector) {
            throw new Error('connectionControllerClient:connectExternal - connector is undefined');
        }
        await reconnect(this.wagmiConfig, {
            connectors: [connector]
        });
    }
    async getBalance(params) {
        const address = params.address;
        const caipNetwork = this.getCaipNetworks().find(network => network.id === params.chainId);
        if (!address) {
            return Promise.resolve({ balance: '0.00', symbol: 'ETH' });
        }
        if (caipNetwork && this.wagmiConfig) {
            const caipAddress = `${caipNetwork.caipNetworkId}:${params.address}`;
            const cachedPromise = this.balancePromises[caipAddress];
            if (cachedPromise) {
                return cachedPromise;
            }
            const cachedBalance = StorageUtil.getNativeBalanceCacheForCaipAddress(caipAddress);
            if (cachedBalance) {
                return { balance: cachedBalance.balance, symbol: cachedBalance.symbol };
            }
            this.balancePromises[caipAddress] = new Promise(async (resolve) => {
                try {
                    const chainId = Number(params.chainId);
                    const balance = await getBalance(this.wagmiConfig, {
                        address: params.address,
                        chainId,
                        token: params.tokens?.[caipNetwork.caipNetworkId]?.address
                    });
                    StorageUtil.updateNativeBalanceCache({
                        caipAddress,
                        balance: balance.formatted,
                        symbol: balance.symbol,
                        timestamp: Date.now()
                    });
                    resolve({ balance: balance.formatted, symbol: balance.symbol });
                }
                catch (error) {
                    console.warn('Appkit:WagmiAdapter:getBalance - Error getting balance', error);
                    resolve({ balance: '0.00', symbol: 'ETH' });
                }
            }).finally(() => {
                delete this.balancePromises[caipAddress];
            });
            return this.balancePromises[caipAddress] || { balance: '0.00', symbol: 'ETH' };
        }
        return { balance: '', symbol: '' };
    }
    getWalletConnectProvider() {
        return this.getWagmiConnector('walletConnect')?.['provider'];
    }
    async disconnect(params) {
        if (params.id) {
            const connector = this.getWagmiConnector(params.id);
            const connections = getConnections(this.wagmiConfig);
            const connection = connections.find(c => HelpersUtil.isLowerCaseMatch(c.connector.id, params.id));
            await wagmiDisconnect(this.wagmiConfig, { connector });
            if (OptionsController.state.enableReconnect === false) {
                this.deleteConnection(params.id);
            }
            if (connection) {
                return {
                    connections: [
                        {
                            accounts: connection.accounts.map(account => ({
                                address: this.toChecksummedAddress(account)
                            })),
                            connectorId: connection.connector.id
                        }
                    ]
                };
            }
            return { connections: [] };
        }
        return this.disconnectAll();
    }
    async disconnectAll() {
        const wagmiConnections = getConnections(this.wagmiConfig);
        const connections = await Promise.allSettled(wagmiConnections.map(async (connection) => {
            const connector = this.getWagmiConnector(connection.connector.id);
            if (connector) {
                await wagmiDisconnect(this.wagmiConfig, { connector });
            }
            return connection;
        }));
        this.wagmiConfig.state.connections.clear();
        return {
            connections: connections
                .filter(connection => connection.status === 'fulfilled')
                .map(({ value: connection }) => ({
                accounts: connection.accounts.map(account => ({
                    address: this.toChecksummedAddress(account)
                })),
                connectorId: connection.connector.id
            }))
        };
    }
    async switchNetwork(params) {
        const { caipNetwork } = params;
        const wagmiChain = this.wagmiConfig.chains.find(chain => chain.id.toString() === caipNetwork.id.toString());
        if (!wagmiChain) {
            throw new Error('connectionControllerClient:switchNetwork - wagmiChain is undefined');
        }
        const { name, nativeCurrency, rpcUrls, blockExplorers, id } = wagmiChain;
        const rpcUrl = caipNetwork.rpcUrls?.['chainDefault']?.http?.[0] ?? rpcUrls.default.http[0] ?? '';
        const blockExplorerUrl = blockExplorers?.default.url ?? caipNetwork.blockExplorers?.default?.url ?? '';
        const currency = nativeCurrency ?? caipNetwork.nativeCurrency;
        const chainName = name ?? caipNetwork.name;
        await switchChain(this.wagmiConfig, {
            chainId: id,
            addEthereumChainParameter: {
                chainName,
                nativeCurrency: currency,
                rpcUrls: [rpcUrl],
                blockExplorerUrls: [blockExplorerUrl]
            }
        });
        await super.switchNetwork(params);
    }
    async getCapabilities(params) {
        if (!this.wagmiConfig) {
            throw new Error('connectionControllerClient:getCapabilities - wagmiConfig is undefined');
        }
        const connections = getConnections(this.wagmiConfig);
        const connection = connections[0];
        const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
        if (!connector) {
            throw new Error('connectionControllerClient:getCapabilities - connector is undefined');
        }
        const provider = (await connector.getProvider());
        if (!provider) {
            throw new Error('connectionControllerClient:getCapabilities - provider is undefined');
        }
        return await provider.request({ method: 'wallet_getCapabilities', params: [params] });
    }
    async grantPermissions(params) {
        if (!this.wagmiConfig) {
            throw new Error('connectionControllerClient:grantPermissions - wagmiConfig is undefined');
        }
        const connections = getConnections(this.wagmiConfig);
        const connection = connections[0];
        const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
        if (!connector) {
            throw new Error('connectionControllerClient:grantPermissions - connector is undefined');
        }
        const provider = (await connector.getProvider());
        if (!provider) {
            throw new Error('connectionControllerClient:grantPermissions - provider is undefined');
        }
        return provider.request({ method: 'wallet_grantPermissions', params });
    }
    async revokePermissions(params) {
        if (!this.wagmiConfig) {
            throw new Error('connectionControllerClient:revokePermissions - wagmiConfig is undefined');
        }
        const connections = getConnections(this.wagmiConfig);
        const connection = connections[0];
        const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
        if (!connector) {
            throw new Error('connectionControllerClient:revokePermissions - connector is undefined');
        }
        const provider = (await connector.getProvider());
        if (!provider) {
            throw new Error('connectionControllerClient:revokePermissions - provider is undefined');
        }
        return provider.request({ method: 'wallet_revokePermissions', params });
    }
    async walletGetAssets(params) {
        if (!this.wagmiConfig) {
            throw new Error('connectionControllerClient:walletGetAssets - wagmiConfig is undefined');
        }
        const connections = getConnections(this.wagmiConfig);
        const connection = connections[0];
        const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
        if (!connector) {
            throw new Error('connectionControllerClient:walletGetAssets - connector is undefined');
        }
        const provider = (await connector.getProvider());
        if (!provider) {
            throw new Error('connectionControllerClient:walletGetAssets - provider is undefined');
        }
        return provider.request({ method: 'wallet_getAssets', params: [params] });
    }
    setAuthProvider(authProvider) {
        if (!this.namespace) {
            throw new Error('WagmiAdapter:setAuthProvider - namespace is required');
        }
        this.addConnector({
            id: CommonConstantsUtil.CONNECTOR_ID.AUTH,
            type: 'AUTH',
            name: CommonConstantsUtil.CONNECTOR_NAMES.AUTH,
            provider: authProvider,
            imageId: PresetsUtil.ConnectorImageIds[CommonConstantsUtil.CONNECTOR_ID.AUTH],
            chain: this.namespace,
            chains: []
        });
    }
    async setUniversalProvider(universalProvider) {
        universalProvider.on('connect', () => {
            const connections = getConnections(this.wagmiConfig);
            const connector = this.getWagmiConnector('walletConnect');
            if (connector && !connections.find(c => c.connector.id === connector.id)) {
                if (ChainController.state.activeChain === 'eip155') {
                    return;
                }
                reconnect(this.wagmiConfig, {
                    connectors: [connector]
                });
            }
        });
        const walletConnectConnector = walletConnect({
            universalProvider
        });
        this.configureInternalConnector(walletConnectConnector);
        this.addConnector(new WalletConnectConnector({
            provider: universalProvider,
            caipNetworks: this.getCaipNetworks(),
            namespace: 'eip155'
        }));
        return Promise.resolve();
    }
    toChecksummedAddress(address) {
        return checksumAddress(address.toLowerCase());
    }
}
//# sourceMappingURL=client.js.map